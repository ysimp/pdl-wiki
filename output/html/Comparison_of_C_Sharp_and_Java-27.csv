Java, C#
// The Fibonacci sequence
Stream.generate(new Supplier<Integer>() {
    int a = 0;
    int b = 1;

    public Integer get() {
        int temp = a;
        a = b;
        b = a + temp;
        return temp;
    }
}).limit(10).forEach(System.out::println);, // The Fibonacci sequence
public IEnumerable<int> Fibonacci() 
{
    int a = 0;
    int b = 1;

    while (true) 
    {
        yield return a;
        (a  b) = (b  a + b);
    }
}
, // print the 10 first Fibonacci numbers
foreach (var it in Fibonacci().Take(10)) 
{
    Console.WriteLine(it);
}
Notes for the Java version: The Java 8 Stream interface is a sequence of elements supporting sequential and parallel aggregate operations. The generate method returns an infinite sequential unordered stream where each element is generated by the provided Supplier. The limit method returns a stream consisting of the elements of this stream  truncated to be no longer than maxSize in length. The forEach method performs an action for each element of this stream  this action could be a lambda or a method reference. Concise Way[edit] The above algorithm can be written even more consistently  using Stream.iterate. The iterate method receives a seed parameter  and a function that specifies what to do for each iteration. In this case  the seed can be a Point object with the 2 initial values of the algorithm  and its respective transformation in each iteration. Stream.iterate(new Point(0 1)  p -> new Point(p.y  p.x + p.y))
    .limit(10)
    .map(p -> p.x)
    .forEach(System.out::println);, Notes for the C# version: The method is defined as returning instances of the interface IEnumerable<int>  which allows client code to repeatedly request the next number of a sequence. The yield keyword converts the method into a generator method. The yield return statement returns the next number of the sequence and creates a continuation so that subsequent invocations of the IEnumerable interface's MoveNext method will continue execution from the following statement with all local variables intact. Tuple-assignment avoids the need to create and use a temporary variable when updating the values of the variables a and b.
