! calling a function, basic/void function, value-returning function, required main function
 Ada[1], foo «(parameters)», procedure foo «(parameters)» is begin statements end foo, function foo «(parameters)» return type is begin statements end foo, {{n/a}}
 ALGOL 68, foo«(parameters)»;, proc foo = «(parameters)» void: ( instructions );, proc foo = «(parameters)» rettype: ( instructions ...; retvalue );, {{n/a}}
 APL, «parameters» foo parameters, foo?{ statements }, foo?{ statements }, {{n/a}}
 C (C99), foo(«parameters»), void foo(«parameters») { instructions }, type foo(«parameters») { instructions ... return value; }, «global declarations» int main(«int argc  char *argv[]») { <dl><dd> instructions </dd></dl> }
 Objective-C
 C++ (STL)
 Java, public static void main(String[] args) { instructions } or public static void main(String... args) { instructions }
 D, int main(«char[][] args») { instructions} or int main(«string[] args») { instructions} or void main(«char[][] args») { instructions} or void main(«string[] args») { instructions}
 C#, Same as above; alternatively  if only one statement: void foo(«parameters») => statement;, Same as above; alternatively  if simple enough to be an expression: void foo(«parameters») => expression;, static void Main(«string[] args») method_body May instead return int. (starting with C# 7.1:) May return Task or Task<int>  and if so  may be async.
 JavaScript, function foo(«parameters») { instructions } or var foo = function («parameters») {instructions } or var foo = new Function («"parameter"  ...  "last parameter"» "instructions");, function foo(«parameters») { instructions ... return value; }, {{n/a}}
 Go, func foo(«parameters») { instructions }, func foo(«parameters») type { instructions ... return value }, func main() { instructions }
 Swift, func foo(«parameters») { instructions }, func foo(«parameters») -> type { instructions ... return value }, {{n/a}}
 Common Lisp, (foo «parameters»), (defun foo («parameters»)<dl><dd>instructions)</dd></dl> or (setf (symbol-function 'symbol)<dl><dd>lambda)</dd></dl>, (defun foo («parameters»)<dl><dd>...</dd><dd>value)</dd></dl>, rowspan=3 {{n/a}}
 Scheme, (define (foo parameters) instructions) or (define foo (lambda (parameters) instructions)), (define (foo parameters) instructions... return_value) or (define foo (lambda (parameters) instructions... return_value))
 ISLISP, (defun foo («parameters»)<dl><dd>instructions)</dd></dl>, (defun foo («parameters»)<dl><dd>...</dd><dd>value)</dd></dl>
 Pascal, foo«(parameters)», procedure foo«(parameters)»; «forward;»{{ref|forward declaration|[a]}} «label<dl><dd>label declarations»</dd></dl> «const<dl><dd>constant declarations»</dd></dl> «type<dl><dd>type declarations»</dd></dl> «var<dl><dd>variable declarations»</dd></dl> «local function declarations» begin<dl><dd>instructions</dd></dl>end;, function foo«(parameters)»: type; «forward;»{{ref|forward declaration|[a]}} «label<dl><dd>label declarations»</dd></dl> «const<dl><dd>constant declarations»</dd></dl> «type<dl><dd>type declarations»</dd></dl> «var<dl><dd>variable declarations»</dd></dl> «local function declarations» begin<dl><dd> instructions; foo := value</dd></dl>end;, program name; «label<dl><dd>label declarations»</dd></dl> «const<dl><dd>constant declarations»</dd></dl> «type<dl><dd>type declarations»</dd></dl> «var<dl><dd>variable declarations»</dd></dl> «function declarations» begin<dl><dd>instructions</dd></dl> end.
 Visual Basic, Foo(«parameters»), Sub Foo«(parameters)»<dl><dd> instructions </dd></dl> End Sub, Function Foo«(parameters)»« As type»<dl><dd>instructions Foo = value</dd></dl>End Function, Sub Main()<dl><dd>instructions</dd></dl>End Sub
 Visual Basic .NET, Same as above; alternatively: Function Foo«(parameters)»« As type»<dl><dd>instructions Return value</dd></dl>End Function The As clause is not required if Option Strict is off. A type character may be used instead of the As clause. If control exits the function without a return value having been explicitly specified  the function returns the default value for the return type., Sub Main(««ByVal »args() As String») <dl><dd> instructions </dd></dl> End Subor Function Main(««ByVal »args() As String») As Integer <dl><dd>instructions</dd></dl>End Function
 Xojo
 Python, foo(«parameters»), def foo(«parameters»): {{keypress|Tab}} instructions, def foo(«parameters»): {{keypress|Tab}} instructions {{keypress|Tab}} return value, {{n/a}}
 S-Lang, foo(«parameters» «;qualifiers»), define foo («parameters») { instructions }, define foo («parameters») { instructions ... return value; }, public define slsh_main () { instructions }
 Fortran, foo («arguments») CALL sub_foo («arguments»){{ref|Fortran arguments|[c]}}, SUBROUTINE sub_foo («arguments») <dl><dd> instructions </dd></dl> END SUBROUTINE{{ref|Fortran arguments|[c]}}, type FUNCTION foo («arguments») <dl><dd> instructions ... foo = value </dd></dl> END FUNCTION{{ref|Fortran arguments|[c]}}, PROGRAM main <dl><dd> instructions </dd></dl> END PROGRAM
 Forth, «parameters» FOO, : FOO « stack effect comment: ( before -- ) » <dl><dd> instructions </dd></dl> ;, : FOO « stack effect comment: ( before -- after ) » <dl><dd> instructions </dd></dl> ;, {{n/a}}
 PHP, foo(«parameters»), function foo(«parameters») { instructions }, function foo(«parameters») { instructions ... return value; }, rowspan=4 {{n/a}}
 Perl, foo(«parameters») or &foo«(parameters)», sub foo { «my (parameters) = @_;» instructions }, sub foo { «my (parameters) = @_;» instructions... «return» value; }
 Perl 6, foo(«parameters») or &foo«(parameters)», «multi »sub foo(parameters) { instructions }, «our «type» »«multi »sub foo(parameters) { instructions... «return» value; }
 Ruby, foo«(parameters)», def foo«(parameters)» <dl><dd>instructions </dd></dl> end, def foo«(parameters)» <dl><dd>instructions «return» value </dd></dl> end
 Rust, foo(«paramaters»), fn foo(«paramaters») { instructions }, fn foo(«paramaters») -> type { instructions }, fn main() { instructions }
 Scala, foo«(parameters)», def foo«(parameters)»«: Unit =» { instructions }, def foo«(parameters)»«: type» = { instructions ... «return» value }, def main(args: Array[String]) { instructions }
 Windows PowerShell, foo «parameters», function foo { instructions }; or function foo { «param(parameters)» instructions }, function foo «(parameters)» { instructions … return value }; or function foo { «param(parameters)» instructions … return value }, rowspan=4 {{n/a}}
 Bash shell, foo «parameters», <poem>function foo { {{space|4}}instructions } or foo () { {{space|4}}instructions }</poem>, <poem>function foo { {{space|4}}instructions {{space|4}}return «exit_code» } or foo () { {{space|4}}instructions {{space|4}}return «exit_code» }</poem>
 parameters $n ($1  $2  $3  ...) $@ (all parameters) $# (the number of parameters) $0 (this function name)
 OCaml, foo parameters, let «rec» foo parameters = instructions, let «rec» foo parameters = instructions... return_value
 F#, [<EntryPoint>] let main args = instructions
 Standard ML, fun foo parameters = ( instructions ), fun foo parameters = ( instructions... return_value ), 
 Haskell, foo parameters = do {{keypress|Tab}} instructions, foo parameters = return_value or foo parameters = do {{keypress|Tab}} instructions {{keypress|Tab}} return value, «main :: IO ()» main = do instructions
 Eiffel, foo («parameters»), foo («parameters») <dl><dd>require <dl><dd>preconditions</dd></dl> do <dl><dd>instructions</dd></dl> ensure <dl><dd>postconditions</dd></dl> end</dd></dl>, foo («parameters»): type <dl><dd>require <dl><dd>preconditions</dd></dl> do <dl><dd>instructions</dd><dd>Result := value</dd></dl> ensure <dl><dd>postconditions</dd></dl> end</dd></dl>, {{ref|root class and feature|[b]}}
 CoffeeScript, foo(), foo = ->, foo = -> value, rowspan=2 {{n/a}}
 foo parameters, foo = () ->, foo = ( parameters ) -> value
 COBOL, CALL "foo" «USING parameters» <dl><dd> «exception-handling» </dd></dl> «END-CALL»{{ref|COBOL calling programs|[d]}}, «IDENTIFICATION DIVISION.» PROGRAM-ID. foo. «other divisions...» PROCEDURE DIVISION «USING parameters». <dl><dd> instructions.</dd></dl>, «IDENTIFICATION DIVISION.» PROGRAM-ID/FUNCTION-